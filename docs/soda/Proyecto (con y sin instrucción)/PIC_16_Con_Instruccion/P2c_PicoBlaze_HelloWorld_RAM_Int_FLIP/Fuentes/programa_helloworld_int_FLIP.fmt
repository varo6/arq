  1   0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2   0              ;                 
  3   0              ;Transmision RS-232 por software. 
  4   0              ;115200bps, 8 data bits, no parity, 1 stop bit, no flow control,
  5   0              ;parte1: transmite por el puerte serie el contenido de la memoria RAM (64 bytes, portid [0-63])
  6   0              ;parte2: genera numeros pseudo-aleatorios, bucle contador+interrupcion para transmitir numero.
  7   0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  8   0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  9   0              ;declaracion de constantes y variables
 10   0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                  
 11   0              :CONSTANT   RS232        00FF         ; puerto comunicacion serie es el FF
 12   0              ; rx es el bit 0 del puerto FF(entrada)
 13   0              ; tx es el bit 7 del puerto FF(salida), esto es porque
 14   0              ;el hyperterminal envia primero el LSB, por eso vamos desplazando a la 
 15   0              ;izquierda al recibir, y al enviar tambien, con lo que enviamos de nuevo
 16   0              ;el LSB primero como corresponde para que lo entienda el hyperterminal
 17   0              :NAMEREG    S12          TXREG        ;buffer de transmision cambiado para probar nuevas registros
 18   0              :NAMEREG    S8           RXREG        ;buffer de recepcion cambiado para probar nuevas registros
 19   0              :NAMEREG    S3           CONTBIT      ;contador de los 8 bits de datos
 20   0              :NAMEREG    S4           CONT1        ;contador de retardo1
 21   0              :NAMEREG    S5           CONT2        ;contador de retardo2
 22   0              ;
 23   0              :ADDRESS    0000         ;el programa se cargara a partir de la dir 0000
 24   0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 25   0              ;Inicio del programa
 26   0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 27   0              :DISABLE    INTERRUPT    
 28   1 START        :CALL       RECIBE       
 29   2              ;Instrucciones para la parte1
 30   2              :LOAD       S7           0000         
 31   3 PARTE1       :INPUT      TXREG        S7           
 32   4              :ADD        TXREG        0000         
 33   5              :JUMP       Z            PARTE2       
 34   6              :CALL       TRANSMITE    
 35   7              :ADD        S7           0001         
 36   8              :JUMP       PARTE1       
 37   9              ;Instrucciones para la parte2
 38   9 PARTE2       :ENABLE     INTERRUPT    
 39   A BUCLE1       :LOAD       S6           0009         
 40   B BUCLE2       :SUB        S6           0001         
 41   C              :JUMP       NZ           BUCLE2       
 42   D              :LOAD       S6           0009         
 43   E              :JUMP       BUCLE2       
 44   F              
 45   F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 46   F              ;Rutina de recepcion de caracteres
 47   F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 48   F RECIBE       ;esperamos a que se reciba un bit de inicio
 49   F              :INPUT      RXREG        RS232        
 50  10              :AND        RXREG        8000         ;ahora que usamos MIX se vuelve a tomar el valor del bit numero 0080 antes 8000 (no del final) ?
 51  11              :JUMP       NZ           RECIBE       
 52  12              :CALL       WAIT_05BIT   
 53  13              ;almacenamos los 8 bits de datos
 54  13              :LOAD       CONTBIT      0009         ;sin mix, esto nos permite llevar el bit 16 a la posicion deseada
 55  14 NEXT_RX_BIT  :CALL       WAIT_1BIT    
 56  15              :SR0        RXREG        
 57  16              :INPUT      S0           RS232        
 58  17              :AND        S0           8000         ;ahora que usamos MIX se vuelve a tomar el valor del bit numero 0080 antes 8000 (no del final) ?
 59  18              :OR         RXREG        S0           
 60  19              :SUB        CONTBIT      0001         
 61  1A              :JUMP       NZ           NEXT_RX_BIT  
 62  1B              :MIX        RXREG        
 63  1C              :RETURN     
 64  1D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 65  1D              ;Rutina de transmision de caracteres
 66  1D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 67  1D TRANSMITE    ;enviamos un bit de inicio
 68  1D              :LOAD       S0           0000         
 69  1E              :OUTPUT     S0           RS232        
 70  1F              :CALL       WAIT_1BIT    
 71  20              ;enviamos los 8 bits de datos
 72  20              :LOAD       CONTBIT      0008         
 73  21 NEXT_TX_BIT  :OUTPUT     TXREG        RS232        
 74  22              :CALL       WAIT_1BIT    
 75  23              :SR0        TXREG        
 76  24              :SUB        CONTBIT      0001         
 77  25              :JUMP       NZ           NEXT_TX_BIT  
 78  26              ;enviamos un bit de parada
 79  26              :LOAD       S0           00FF         
 80  27              :OUTPUT     S0           RS232        
 81  28              :CALL       WAIT_1BIT    
 82  29              :RETURN     
 83  2A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 84  2A              ;Rutina espera 1 bit (a 9600bps)
 85  2A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 86  2A              ;clk=50MHz, 9600bps, cont1=0A, cont2=80
 87  2A              ;esta rutina ejecuta 1 + (1 + 10*(1 + 128*2 + 2)) + 1 = 2593 instruciones,
 88  2A              ;aproximandose al numero teorico de (104,16us/bit)/(0,04 us/instruc) = 2604,166 instr/bit necesarias.
 89  2A              ;clk=40MHz, 57600bps, cont1=05, cont2=21
 90  2A              ;esta rutina ejecuta 1 + (1 + 5*(1 + 33*2 + 2)) + 1 =  instruciones,
 91  2A              ;aproximandose al numero teorico de (17,36us/bit)/(0,05 us/instruc) = 347,2 instr/bit necesarias.
 92  2A              ;clk=50MHz, 115200bps, cont1=03, cont2=22
 93  2A              ;esta rutina ejecuta 1 + (1 + 3*(1 + 34*2 + 2)) + 1 = 216 instruciones,
 94  2A              ;aproximandose al numero teorico de (8,68us/bit)/(0,04 us/instruc) = 217 instr/bit necesarias.
 95  2A              ;clk=50MHz, 230400bps, cont1= 03, cont2= 10
 96  2A              ;esta rutina ejecuta 1 + (1 + 3*(1 + 16*2 + 2)) + 1 = 108 instruciones,
 97  2A              ;aproximandose al numero teorico de (4,34us/bit)/(0,04 us/instruc) = 108,5 instr/bit necesarias.
 98  2A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 99  2A              ;OJO: con el USB2COM no he conseguido pasar de los 230400bps bien. 
100  2A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
101  2A              ;clk=50MHz, 460800bps, cont1= 03, cont2=06 OJO:Hay que ponerle 1 menos a cont2 y que tome 
102  2A              ;caracteres ascii de 7 bits para que funcione.
103  2A              ;esta rutina ejecuta 1 + (1 + 3*(1 + 7*2 + 2)) + 1 = 54 instruciones,
104  2A              ;aproximandose al numero teorico de (2,17us/bit)/(0,04 us/instruc) = 54,25 instr/bit necesarias.
105  2A              ;clk=50MHz, 921600bps, cont1=01, cont2=0A NO FUNCIONA
106  2A              ;esta rutina ejecuta 1 + (1 + 1*(1 + 10*2 + 2)) + 1 = 26 instruciones,
107  2A              ;aproximandose al numero teorico de (1,085us/bit)/(0,04 us/instruc) = 27,127 instr/bit necesarias.
108  2A WAIT_1BIT    :LOAD       CONT1        0003         
109  2B ESPERA2      :LOAD       CONT2        0022         
110  2C ESPERA1      :SUB        CONT2        0001         
111  2D              :JUMP       NZ           ESPERA1      
112  2E              :SUB        CONT1        0001         
113  2F              :JUMP       NZ           ESPERA2      
114  30              :RETURN     
115  31              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
116  31              ;Rutina espera 0,5 bits (bit de inicio, a 9600bps)
117  31              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
118  31              ;clk=50MHz, 9600bps, cont1=05, cont2=80
119  31              ;1 + (1 + 5*(1 + 128*2 + 2)) + 1 = 1298; aprox = 1302
120  31              ;clk=40MHz, 57600bps, cont1=03, cont2=1B
121  31              ;1 + (1 + 3*(1 + 27*2 + 2)) + 1 = 1298; aprox = 173.6
122  31              ;clk=50MHz, 115200bps, cont1=03, cont2=10
123  31              ;1 + (1 + 3*(1 + 16*2 + 2)) + 1 = 108; aprox = 108.5
124  31              ;clk=50MHz, 230400bps, cont1= 03, cont2= 07
125  31              ;1 + (1 + 3*(1 + 7*2 + 2)) + 1 = 54; aprox = 54,25
126  31              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
127  31              ;OJO: con el USB2COM no he conseguido pasar de los 230400bps bien. 
128  31              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
129  31              ;clk=50MHz, 460800bps, cont1= 01, cont2= 0A
130  31              ;1 + (1 + 1*(1 + 10*2 + 2)) + 1 = 26; aprox = 27,125
131  31              ;clk=50MHz, 921600bps, cont1=01, cont2=04 NO FUNCIONA
132  31              ;1 + (1 + 1*(1 + 4*2 + 2)) + 1 = 14; aprox = 13,56
133  31 WAIT_05BIT   :LOAD       CONT1        0003         
134  32 ESPERA4      :LOAD       CONT2        0010         
135  33 ESPERA3      :SUB        CONT2        0001         
136  34              :JUMP       NZ           ESPERA3      
137  35              :SUB        CONT1        0001         
138  36              :JUMP       NZ           ESPERA4      
139  37              :RETURN     
140  38              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
141  38              ; FIN
142  38              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
143  38              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
144  38              ; RUTINA DE ATENCION A LA INTERRUPCIÓN
145  38              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
146  38 INTERRUP     :DISABLE    INTERRUPT    
147  39              :CALL       RECIBE       
148  3A              ;FLIP		rxreg
149  3A              :LOAD       TXREG        RXREG        
150  3B              :CALL       TRANSMITE    
151  3C              :ADD        S6           0030         ;le sumamos el valor 30 a lo que recibimos, de manera que corresponda con el caracter ASCII de la tecla pulsad
152  3D              
153  3D              :LOAD       TXREG        S6           
154  3E              :CALL       TRANSMITE    
155  3F              :RETURNI    ENABLE       
156 FFFF              :ADDRESS    FFFF         
157 FFFF              :JUMP       INTERRUP     
